<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../../../">
  <title data-ice="title">js/test/node_modules/minimatch/minimatch.js | API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/js/abstract.js~AbstractHierarchy.html">AbstractHierarchy</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/js/character.js~Char.html">Char</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/js/character.js~EOL.html">EOL</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/js/character.js~Paragraph.html">Paragraph</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/js/character.js~Row.html">Row</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/js/container.js~Displayer.html">Displayer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/js/container.js~SearchMode.html">SearchMode</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/js/container.js~SelectRange.html">SelectRange</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/js/container.js~SentenceContainer.html">SentenceContainer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/js/filelist.js~Directory.html">Directory</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/js/filelist.js~File.html">File</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/js/filelist.js~FileList.html">FileList</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/js/input.js~ConvertContainer.html">ConvertContainer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/js/input.js~ConvertView.html">ConvertView</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/js/input.js~InputBuffer.html">InputBuffer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/js/input.js~InputChar.html">InputChar</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/js/other-classes.js~CommandLine.html">CommandLine</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/js/other-classes.js~Cursor.html">Cursor</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/js/other-classes.js~Menu.html">Menu</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/js/undo-redo.js~BoldDoMemory.html">BoldDoMemory</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/js/undo-redo.js~ColorDoMemory.html">ColorDoMemory</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/js/undo-redo.js~DeleteDoMemory.html">DeleteDoMemory</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/js/undo-redo.js~DoManager.html">DoManager</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/js/undo-redo.js~DoMemory.html">DoMemory</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/js/undo-redo.js~FontSizeDoMemory.html">FontSizeDoMemory</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/js/undo-redo.js~ItalicDoMemory.html">ItalicDoMemory</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/js/undo-redo.js~LineBreakDoMemory.html">LineBreakDoMemory</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/js/undo-redo.js~PrintDoMemory.html">PrintDoMemory</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-ElemCreator">ElemCreator</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-KeyTable">KeyTable</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-Util">Util</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">js/test/node_modules/minimatch/minimatch.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">module.exports = minimatch
minimatch.Minimatch = Minimatch

var path = { sep: &apos;/&apos; }
try {
  path = require(&apos;path&apos;)
} catch (er) {}

var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}
var expand = require(&apos;brace-expansion&apos;)

var plTypes = {
  &apos;!&apos;: { open: &apos;(?:(?!(?:&apos;, close: &apos;))[^/]*?)&apos;},
  &apos;?&apos;: { open: &apos;(?:&apos;, close: &apos;)?&apos; },
  &apos;+&apos;: { open: &apos;(?:&apos;, close: &apos;)+&apos; },
  &apos;*&apos;: { open: &apos;(?:&apos;, close: &apos;)*&apos; },
  &apos;@&apos;: { open: &apos;(?:&apos;, close: &apos;)&apos; }
}

// any single thing other than /
// don&apos;t need to escape / when using new RegExp()
var qmark = &apos;[^/]&apos;

// * =&gt; any number of characters
var star = qmark + &apos;*?&apos;

// ** when dots are allowed.  Anything goes, except .. and .
// not (^ or / followed by one or two dots followed by $ or /),
// followed by anything, any number of times.
var twoStarDot = &apos;(?:(?!(?:\\\/|^)(?:\\.{1,2})($|\\\/)).)*?&apos;

// not a ^ or / followed by a dot,
// followed by anything, any number of times.
var twoStarNoDot = &apos;(?:(?!(?:\\\/|^)\\.).)*?&apos;

// characters that need to be escaped in RegExp.
var reSpecials = charSet(&apos;().*{}+?[]^$\\!&apos;)

// &quot;abc&quot; -&gt; { a:true, b:true, c:true }
function charSet (s) {
  return s.split(&apos;&apos;).reduce(function (set, c) {
    set[c] = true
    return set
  }, {})
}

// normalizes slashes.
var slashSplit = /\/+/

minimatch.filter = filter
function filter (pattern, options) {
  options = options || {}
  return function (p, i, list) {
    return minimatch(p, pattern, options)
  }
}

function ext (a, b) {
  a = a || {}
  b = b || {}
  var t = {}
  Object.keys(b).forEach(function (k) {
    t[k] = b[k]
  })
  Object.keys(a).forEach(function (k) {
    t[k] = a[k]
  })
  return t
}

minimatch.defaults = function (def) {
  if (!def || !Object.keys(def).length) return minimatch

  var orig = minimatch

  var m = function minimatch (p, pattern, options) {
    return orig.minimatch(p, pattern, ext(def, options))
  }

  m.Minimatch = function Minimatch (pattern, options) {
    return new orig.Minimatch(pattern, ext(def, options))
  }

  return m
}

Minimatch.defaults = function (def) {
  if (!def || !Object.keys(def).length) return Minimatch
  return minimatch.defaults(def).Minimatch
}

function minimatch (p, pattern, options) {
  if (typeof pattern !== &apos;string&apos;) {
    throw new TypeError(&apos;glob pattern string required&apos;)
  }

  if (!options) options = {}

  // shortcut: comments match nothing.
  if (!options.nocomment &amp;&amp; pattern.charAt(0) === &apos;#&apos;) {
    return false
  }

  // &quot;&quot; only matches &quot;&quot;
  if (pattern.trim() === &apos;&apos;) return p === &apos;&apos;

  return new Minimatch(pattern, options).match(p)
}

function Minimatch (pattern, options) {
  if (!(this instanceof Minimatch)) {
    return new Minimatch(pattern, options)
  }

  if (typeof pattern !== &apos;string&apos;) {
    throw new TypeError(&apos;glob pattern string required&apos;)
  }

  if (!options) options = {}
  pattern = pattern.trim()

  // windows support: need to use /, not \
  if (path.sep !== &apos;/&apos;) {
    pattern = pattern.split(path.sep).join(&apos;/&apos;)
  }

  this.options = options
  this.set = []
  this.pattern = pattern
  this.regexp = null
  this.negate = false
  this.comment = false
  this.empty = false

  // make the set of regexps etc.
  this.make()
}

Minimatch.prototype.debug = function () {}

Minimatch.prototype.make = make
function make () {
  // don&apos;t do it more than once.
  if (this._made) return

  var pattern = this.pattern
  var options = this.options

  // empty patterns and comments match nothing.
  if (!options.nocomment &amp;&amp; pattern.charAt(0) === &apos;#&apos;) {
    this.comment = true
    return
  }
  if (!pattern) {
    this.empty = true
    return
  }

  // step 1: figure out negation, etc.
  this.parseNegate()

  // step 2: expand braces
  var set = this.globSet = this.braceExpand()

  if (options.debug) this.debug = console.error

  this.debug(this.pattern, set)

  // step 3: now we have a set, so turn each one into a series of path-portion
  // matching patterns.
  // These will be regexps, except in the case of &quot;**&quot;, which is
  // set to the GLOBSTAR object for globstar behavior,
  // and will not contain any / characters
  set = this.globParts = set.map(function (s) {
    return s.split(slashSplit)
  })

  this.debug(this.pattern, set)

  // glob --&gt; regexps
  set = set.map(function (s, si, set) {
    return s.map(this.parse, this)
  }, this)

  this.debug(this.pattern, set)

  // filter out everything that didn&apos;t compile properly.
  set = set.filter(function (s) {
    return s.indexOf(false) === -1
  })

  this.debug(this.pattern, set)

  this.set = set
}

Minimatch.prototype.parseNegate = parseNegate
function parseNegate () {
  var pattern = this.pattern
  var negate = false
  var options = this.options
  var negateOffset = 0

  if (options.nonegate) return

  for (var i = 0, l = pattern.length
    ; i &lt; l &amp;&amp; pattern.charAt(i) === &apos;!&apos;
    ; i++) {
    negate = !negate
    negateOffset++
  }

  if (negateOffset) this.pattern = pattern.substr(negateOffset)
  this.negate = negate
}

// Brace expansion:
// a{b,c}d -&gt; abd acd
// a{b,}c -&gt; abc ac
// a{0..3}d -&gt; a0d a1d a2d a3d
// a{b,c{d,e}f}g -&gt; abg acdfg acefg
// a{b,c}d{e,f}g -&gt; abdeg acdeg abdeg abdfg
//
// Invalid sets are not expanded.
// a{2..}b -&gt; a{2..}b
// a{b}c -&gt; a{b}c
minimatch.braceExpand = function (pattern, options) {
  return braceExpand(pattern, options)
}

Minimatch.prototype.braceExpand = braceExpand

function braceExpand (pattern, options) {
  if (!options) {
    if (this instanceof Minimatch) {
      options = this.options
    } else {
      options = {}
    }
  }

  pattern = typeof pattern === &apos;undefined&apos;
    ? this.pattern : pattern

  if (typeof pattern === &apos;undefined&apos;) {
    throw new TypeError(&apos;undefined pattern&apos;)
  }

  if (options.nobrace ||
    !pattern.match(/\{.*\}/)) {
    // shortcut. no need to expand.
    return [pattern]
  }

  return expand(pattern)
}

// parse a component of the expanded set.
// At this point, no pattern may contain &quot;/&quot; in it
// so we&apos;re going to return a 2d array, where each entry is the full
// pattern, split on &apos;/&apos;, and then turned into a regular expression.
// A regexp is made at the end which joins each array with an
// escaped /, and another full one which joins each regexp with |.
//
// Following the lead of Bash 4.1, note that &quot;**&quot; only has special meaning
// when it is the *only* thing in a path portion.  Otherwise, any series
// of * is equivalent to a single *.  Globstar behavior is enabled by
// default, and can be disabled by setting options.noglobstar.
Minimatch.prototype.parse = parse
var SUBPARSE = {}
function parse (pattern, isSub) {
  if (pattern.length &gt; 1024 * 64) {
    throw new TypeError(&apos;pattern is too long&apos;)
  }

  var options = this.options

  // shortcuts
  if (!options.noglobstar &amp;&amp; pattern === &apos;**&apos;) return GLOBSTAR
  if (pattern === &apos;&apos;) return &apos;&apos;

  var re = &apos;&apos;
  var hasMagic = !!options.nocase
  var escaping = false
  // ? =&gt; one single character
  var patternListStack = []
  var negativeLists = []
  var stateChar
  var inClass = false
  var reClassStart = -1
  var classStart = -1
  // . and .. never match anything that doesn&apos;t start with .,
  // even when options.dot is set.
  var patternStart = pattern.charAt(0) === &apos;.&apos; ? &apos;&apos; // anything
  // not (start or / followed by . or .. followed by / or end)
  : options.dot ? &apos;(?!(?:^|\\\/)\\.{1,2}(?:$|\\\/))&apos;
  : &apos;(?!\\.)&apos;
  var self = this

  function clearStateChar () {
    if (stateChar) {
      // we had some state-tracking character
      // that wasn&apos;t consumed by this pass.
      switch (stateChar) {
        case &apos;*&apos;:
          re += star
          hasMagic = true
        break
        case &apos;?&apos;:
          re += qmark
          hasMagic = true
        break
        default:
          re += &apos;\\&apos; + stateChar
        break
      }
      self.debug(&apos;clearStateChar %j %j&apos;, stateChar, re)
      stateChar = false
    }
  }

  for (var i = 0, len = pattern.length, c
    ; (i &lt; len) &amp;&amp; (c = pattern.charAt(i))
    ; i++) {
    this.debug(&apos;%s\t%s %s %j&apos;, pattern, i, re, c)

    // skip over any that are escaped.
    if (escaping &amp;&amp; reSpecials[c]) {
      re += &apos;\\&apos; + c
      escaping = false
      continue
    }

    switch (c) {
      case &apos;/&apos;:
        // completely not allowed, even escaped.
        // Should already be path-split by now.
        return false

      case &apos;\\&apos;:
        clearStateChar()
        escaping = true
      continue

      // the various stateChar values
      // for the &quot;extglob&quot; stuff.
      case &apos;?&apos;:
      case &apos;*&apos;:
      case &apos;+&apos;:
      case &apos;@&apos;:
      case &apos;!&apos;:
        this.debug(&apos;%s\t%s %s %j &lt;-- stateChar&apos;, pattern, i, re, c)

        // all of those are literals inside a class, except that
        // the glob [!a] means [^a] in regexp
        if (inClass) {
          this.debug(&apos;  in class&apos;)
          if (c === &apos;!&apos; &amp;&amp; i === classStart + 1) c = &apos;^&apos;
          re += c
          continue
        }

        // if we already have a stateChar, then it means
        // that there was something like ** or +? in there.
        // Handle the stateChar, then proceed with this one.
        self.debug(&apos;call clearStateChar %j&apos;, stateChar)
        clearStateChar()
        stateChar = c
        // if extglob is disabled, then +(asdf|foo) isn&apos;t a thing.
        // just clear the statechar *now*, rather than even diving into
        // the patternList stuff.
        if (options.noext) clearStateChar()
      continue

      case &apos;(&apos;:
        if (inClass) {
          re += &apos;(&apos;
          continue
        }

        if (!stateChar) {
          re += &apos;\\(&apos;
          continue
        }

        patternListStack.push({
          type: stateChar,
          start: i - 1,
          reStart: re.length,
          open: plTypes[stateChar].open,
          close: plTypes[stateChar].close
        })
        // negation is (?:(?!js)[^/]*)
        re += stateChar === &apos;!&apos; ? &apos;(?:(?!(?:&apos; : &apos;(?:&apos;
        this.debug(&apos;plType %j %j&apos;, stateChar, re)
        stateChar = false
      continue

      case &apos;)&apos;:
        if (inClass || !patternListStack.length) {
          re += &apos;\\)&apos;
          continue
        }

        clearStateChar()
        hasMagic = true
        var pl = patternListStack.pop()
        // negation is (?:(?!js)[^/]*)
        // The others are (?:&lt;pattern&gt;)&lt;type&gt;
        re += pl.close
        if (pl.type === &apos;!&apos;) {
          negativeLists.push(pl)
        }
        pl.reEnd = re.length
      continue

      case &apos;|&apos;:
        if (inClass || !patternListStack.length || escaping) {
          re += &apos;\\|&apos;
          escaping = false
          continue
        }

        clearStateChar()
        re += &apos;|&apos;
      continue

      // these are mostly the same in regexp and glob
      case &apos;[&apos;:
        // swallow any state-tracking char before the [
        clearStateChar()

        if (inClass) {
          re += &apos;\\&apos; + c
          continue
        }

        inClass = true
        classStart = i
        reClassStart = re.length
        re += c
      continue

      case &apos;]&apos;:
        //  a right bracket shall lose its special
        //  meaning and represent itself in
        //  a bracket expression if it occurs
        //  first in the list.  -- POSIX.2 2.8.3.2
        if (i === classStart + 1 || !inClass) {
          re += &apos;\\&apos; + c
          escaping = false
          continue
        }

        // handle the case where we left a class open.
        // &quot;[z-a]&quot; is valid, equivalent to &quot;\[z-a\]&quot;
        if (inClass) {
          // split where the last [ was, make sure we don&apos;t have
          // an invalid re. if so, re-walk the contents of the
          // would-be class to re-translate any characters that
          // were passed through as-is
          // TODO: It would probably be faster to determine this
          // without a try/catch and a new RegExp, but it&apos;s tricky
          // to do safely.  For now, this is safe and works.
          var cs = pattern.substring(classStart + 1, i)
          try {
            RegExp(&apos;[&apos; + cs + &apos;]&apos;)
          } catch (er) {
            // not a valid class!
            var sp = this.parse(cs, SUBPARSE)
            re = re.substr(0, reClassStart) + &apos;\\[&apos; + sp[0] + &apos;\\]&apos;
            hasMagic = hasMagic || sp[1]
            inClass = false
            continue
          }
        }

        // finish up the class.
        hasMagic = true
        inClass = false
        re += c
      continue

      default:
        // swallow any state char that wasn&apos;t consumed
        clearStateChar()

        if (escaping) {
          // no need
          escaping = false
        } else if (reSpecials[c]
          &amp;&amp; !(c === &apos;^&apos; &amp;&amp; inClass)) {
          re += &apos;\\&apos;
        }

        re += c

    } // switch
  } // for

  // handle the case where we left a class open.
  // &quot;[abc&quot; is valid, equivalent to &quot;\[abc&quot;
  if (inClass) {
    // split where the last [ was, and escape it
    // this is a huge pita.  We now have to re-walk
    // the contents of the would-be class to re-translate
    // any characters that were passed through as-is
    cs = pattern.substr(classStart + 1)
    sp = this.parse(cs, SUBPARSE)
    re = re.substr(0, reClassStart) + &apos;\\[&apos; + sp[0]
    hasMagic = hasMagic || sp[1]
  }

  // handle the case where we had a +( thing at the *end*
  // of the pattern.
  // each pattern list stack adds 3 chars, and we need to go through
  // and escape any | chars that were passed through as-is for the regexp.
  // Go through and escape them, taking care not to double-escape any
  // | chars that were already escaped.
  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
    var tail = re.slice(pl.reStart + pl.open.length)
    this.debug(&apos;setting tail&apos;, re, pl)
    // maybe some even number of \, then maybe 1 \, followed by a |
    tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function (_, $1, $2) {
      if (!$2) {
        // the | isn&apos;t already escaped, so escape it.
        $2 = &apos;\\&apos;
      }

      // need to escape all those slashes *again*, without escaping the
      // one that we need for escaping the | character.  As it works out,
      // escaping an even number of slashes can be done by simply repeating
      // it exactly after itself.  That&apos;s why this trick works.
      //
      // I am sorry that you have to see this.
      return $1 + $1 + $2 + &apos;|&apos;
    })

    this.debug(&apos;tail=%j\n   %s&apos;, tail, tail, pl, re)
    var t = pl.type === &apos;*&apos; ? star
      : pl.type === &apos;?&apos; ? qmark
      : &apos;\\&apos; + pl.type

    hasMagic = true
    re = re.slice(0, pl.reStart) + t + &apos;\\(&apos; + tail
  }

  // handle trailing things that only matter at the very end.
  clearStateChar()
  if (escaping) {
    // trailing \\
    re += &apos;\\\\&apos;
  }

  // only need to apply the nodot start if the re starts with
  // something that could conceivably capture a dot
  var addPatternStart = false
  switch (re.charAt(0)) {
    case &apos;.&apos;:
    case &apos;[&apos;:
    case &apos;(&apos;: addPatternStart = true
  }

  // Hack to work around lack of negative lookbehind in JS
  // A pattern like: *.!(x).!(y|z) needs to ensure that a name
  // like &apos;a.xyz.yz&apos; doesn&apos;t match.  So, the first negative
  // lookahead, has to look ALL the way ahead, to the end of
  // the pattern.
  for (var n = negativeLists.length - 1; n &gt; -1; n--) {
    var nl = negativeLists[n]

    var nlBefore = re.slice(0, nl.reStart)
    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8)
    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd)
    var nlAfter = re.slice(nl.reEnd)

    nlLast += nlAfter

    // Handle nested stuff like *(*.js|!(*.json)), where open parens
    // mean that we should *not* include the ) in the bit that is considered
    // &quot;after&quot; the negated section.
    var openParensBefore = nlBefore.split(&apos;(&apos;).length - 1
    var cleanAfter = nlAfter
    for (i = 0; i &lt; openParensBefore; i++) {
      cleanAfter = cleanAfter.replace(/\)[+*?]?/, &apos;&apos;)
    }
    nlAfter = cleanAfter

    var dollar = &apos;&apos;
    if (nlAfter === &apos;&apos; &amp;&amp; isSub !== SUBPARSE) {
      dollar = &apos;$&apos;
    }
    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast
    re = newRe
  }

  // if the re is not &quot;&quot; at this point, then we need to make sure
  // it doesn&apos;t match against an empty path part.
  // Otherwise a/* will match a/, which it should not.
  if (re !== &apos;&apos; &amp;&amp; hasMagic) {
    re = &apos;(?=.)&apos; + re
  }

  if (addPatternStart) {
    re = patternStart + re
  }

  // parsing just a piece of a larger pattern.
  if (isSub === SUBPARSE) {
    return [re, hasMagic]
  }

  // skip the regexp for non-magical patterns
  // unescape anything in it, though, so that it&apos;ll be
  // an exact match against a file etc.
  if (!hasMagic) {
    return globUnescape(pattern)
  }

  var flags = options.nocase ? &apos;i&apos; : &apos;&apos;
  try {
    var regExp = new RegExp(&apos;^&apos; + re + &apos;$&apos;, flags)
  } catch (er) {
    // If it was an invalid regular expression, then it can&apos;t match
    // anything.  This trick looks for a character after the end of
    // the string, which is of course impossible, except in multi-line
    // mode, but it&apos;s not a /m regex.
    return new RegExp(&apos;$.&apos;)
  }

  regExp._glob = pattern
  regExp._src = re

  return regExp
}

minimatch.makeRe = function (pattern, options) {
  return new Minimatch(pattern, options || {}).makeRe()
}

Minimatch.prototype.makeRe = makeRe
function makeRe () {
  if (this.regexp || this.regexp === false) return this.regexp

  // at this point, this.set is a 2d array of partial
  // pattern strings, or &quot;**&quot;.
  //
  // It&apos;s better to use .match().  This function shouldn&apos;t
  // be used, really, but it&apos;s pretty convenient sometimes,
  // when you just want to work with a regex.
  var set = this.set

  if (!set.length) {
    this.regexp = false
    return this.regexp
  }
  var options = this.options

  var twoStar = options.noglobstar ? star
    : options.dot ? twoStarDot
    : twoStarNoDot
  var flags = options.nocase ? &apos;i&apos; : &apos;&apos;

  var re = set.map(function (pattern) {
    return pattern.map(function (p) {
      return (p === GLOBSTAR) ? twoStar
      : (typeof p === &apos;string&apos;) ? regExpEscape(p)
      : p._src
    }).join(&apos;\\\/&apos;)
  }).join(&apos;|&apos;)

  // must match entire pattern
  // ending in a * or ** will make it less strict.
  re = &apos;^(?:&apos; + re + &apos;)$&apos;

  // can match anything, as long as it&apos;s not this.
  if (this.negate) re = &apos;^(?!&apos; + re + &apos;).*$&apos;

  try {
    this.regexp = new RegExp(re, flags)
  } catch (ex) {
    this.regexp = false
  }
  return this.regexp
}

minimatch.match = function (list, pattern, options) {
  options = options || {}
  var mm = new Minimatch(pattern, options)
  list = list.filter(function (f) {
    return mm.match(f)
  })
  if (mm.options.nonull &amp;&amp; !list.length) {
    list.push(pattern)
  }
  return list
}

Minimatch.prototype.match = match
function match (f, partial) {
  this.debug(&apos;match&apos;, f, this.pattern)
  // short-circuit in the case of busted things.
  // comments, etc.
  if (this.comment) return false
  if (this.empty) return f === &apos;&apos;

  if (f === &apos;/&apos; &amp;&amp; partial) return true

  var options = this.options

  // windows: need to use /, not \
  if (path.sep !== &apos;/&apos;) {
    f = f.split(path.sep).join(&apos;/&apos;)
  }

  // treat the test path as a set of pathparts.
  f = f.split(slashSplit)
  this.debug(this.pattern, &apos;split&apos;, f)

  // just ONE of the pattern sets in this.set needs to match
  // in order for it to be valid.  If negating, then just one
  // match means that we have failed.
  // Either way, return on the first hit.

  var set = this.set
  this.debug(this.pattern, &apos;set&apos;, set)

  // Find the basename of the path by looking for the last non-empty segment
  var filename
  var i
  for (i = f.length - 1; i &gt;= 0; i--) {
    filename = f[i]
    if (filename) break
  }

  for (i = 0; i &lt; set.length; i++) {
    var pattern = set[i]
    var file = f
    if (options.matchBase &amp;&amp; pattern.length === 1) {
      file = [filename]
    }
    var hit = this.matchOne(file, pattern, partial)
    if (hit) {
      if (options.flipNegate) return true
      return !this.negate
    }
  }

  // didn&apos;t get any hits.  this is success if it&apos;s a negative
  // pattern, failure otherwise.
  if (options.flipNegate) return false
  return this.negate
}

// set partial to true to test if, for example,
// &quot;/a/b&quot; matches the start of &quot;/*/b/*/d&quot;
// Partial means, if you run out of file before you run
// out of pattern, then that&apos;s fine, as long as all
// the parts match.
Minimatch.prototype.matchOne = function (file, pattern, partial) {
  var options = this.options

  this.debug(&apos;matchOne&apos;,
    { &apos;this&apos;: this, file: file, pattern: pattern })

  this.debug(&apos;matchOne&apos;, file.length, pattern.length)

  for (var fi = 0,
      pi = 0,
      fl = file.length,
      pl = pattern.length
      ; (fi &lt; fl) &amp;&amp; (pi &lt; pl)
      ; fi++, pi++) {
    this.debug(&apos;matchOne loop&apos;)
    var p = pattern[pi]
    var f = file[fi]

    this.debug(pattern, p, f)

    // should be impossible.
    // some invalid regexp stuff in the set.
    if (p === false) return false

    if (p === GLOBSTAR) {
      this.debug(&apos;GLOBSTAR&apos;, [pattern, p, f])

      // &quot;**&quot;
      // a/**/b/**/c would match the following:
      // a/b/x/y/z/c
      // a/x/y/z/b/c
      // a/b/x/b/x/c
      // a/b/c
      // To do this, take the rest of the pattern after
      // the **, and see if it would match the file remainder.
      // If so, return success.
      // If not, the ** &quot;swallows&quot; a segment, and try again.
      // This is recursively awful.
      //
      // a/**/b/**/c matching a/b/x/y/z/c
      // - a matches a
      // - doublestar
      //   - matchOne(b/x/y/z/c, b/**/c)
      //     - b matches b
      //     - doublestar
      //       - matchOne(x/y/z/c, c) -&gt; no
      //       - matchOne(y/z/c, c) -&gt; no
      //       - matchOne(z/c, c) -&gt; no
      //       - matchOne(c, c) yes, hit
      var fr = fi
      var pr = pi + 1
      if (pr === pl) {
        this.debug(&apos;** at the end&apos;)
        // a ** at the end will just swallow the rest.
        // We have found a match.
        // however, it will not swallow /.x, unless
        // options.dot is set.
        // . and .. are *never* matched by **, for explosively
        // exponential reasons.
        for (; fi &lt; fl; fi++) {
          if (file[fi] === &apos;.&apos; || file[fi] === &apos;..&apos; ||
            (!options.dot &amp;&amp; file[fi].charAt(0) === &apos;.&apos;)) return false
        }
        return true
      }

      // ok, let&apos;s see if we can swallow whatever we can.
      while (fr &lt; fl) {
        var swallowee = file[fr]

        this.debug(&apos;\nglobstar while&apos;, file, fr, pattern, pr, swallowee)

        // XXX remove this slice.  Just pass the start index.
        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
          this.debug(&apos;globstar found match!&apos;, fr, fl, swallowee)
          // found a match.
          return true
        } else {
          // can&apos;t swallow &quot;.&quot; or &quot;..&quot; ever.
          // can only swallow &quot;.foo&quot; when explicitly asked.
          if (swallowee === &apos;.&apos; || swallowee === &apos;..&apos; ||
            (!options.dot &amp;&amp; swallowee.charAt(0) === &apos;.&apos;)) {
            this.debug(&apos;dot detected!&apos;, file, fr, pattern, pr)
            break
          }

          // ** swallows a segment, and continue.
          this.debug(&apos;globstar swallow a segment, and continue&apos;)
          fr++
        }
      }

      // no match was found.
      // However, in partial mode, we can&apos;t say this is necessarily over.
      // If there&apos;s more *pattern* left, then
      if (partial) {
        // ran out of file
        this.debug(&apos;\n&gt;&gt;&gt; no match, partial?&apos;, file, fr, pattern, pr)
        if (fr === fl) return true
      }
      return false
    }

    // something other than **
    // non-magic patterns just have to match exactly
    // patterns with magic have been turned into regexps.
    var hit
    if (typeof p === &apos;string&apos;) {
      if (options.nocase) {
        hit = f.toLowerCase() === p.toLowerCase()
      } else {
        hit = f === p
      }
      this.debug(&apos;string match&apos;, p, f, hit)
    } else {
      hit = f.match(p)
      this.debug(&apos;pattern match&apos;, p, f, hit)
    }

    if (!hit) return false
  }

  // Note: ending in / means that we&apos;ll get a final &quot;&quot;
  // at the end of the pattern.  This can only match a
  // corresponding &quot;&quot; at the end of the file.
  // If the file ends in /, then it can only match a
  // a pattern that ends in /, unless the pattern just
  // doesn&apos;t have any more for it. But, a/b/ should *not*
  // match &quot;a/b/*&quot;, even though &quot;&quot; matches against the
  // [^/]*? pattern, except in partial mode, where it might
  // simply not be reached yet.
  // However, a/b/ should still satisfy a/*

  // now either we fell off the end of the pattern, or we&apos;re done.
  if (fi === fl &amp;&amp; pi === pl) {
    // ran out of pattern and filename at the same time.
    // an exact hit!
    return true
  } else if (fi === fl) {
    // ran out of file, but still had pattern left.
    // this is ok if we&apos;re doing the match as part of
    // a glob fs traversal.
    return partial
  } else if (pi === pl) {
    // ran out of pattern, still have file left.
    // this is only acceptable if we&apos;re on the very last
    // empty segment of a file with a trailing slash.
    // a/* should match a/b/
    var emptyFileEnd = (fi === fl - 1) &amp;&amp; (file[fi] === &apos;&apos;)
    return emptyFileEnd
  }

  // should be unreachable.
  throw new Error(&apos;wtf?&apos;)
}

// replace stuff like \* with *
function globUnescape (s) {
  return s.replace(/\\(.)/g, &apos;$1&apos;)
}

function regExpEscape (s) {
  return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, &apos;\\$&amp;&apos;)
}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.5.2)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
